---
layout: post
title: "GNU工具链"
date: 2025-01-07
tags: [GNU工具链，GCC, GDB, gdb, nasm, as, objdump]
---

## GNU binutils系列（编译与反编译）
#### 汇编器-as

#### 汇编器-nasm

#### 链接器-ld

#### 二进制文件分析工具-readelf

#### 反汇编工具-objdump
> 常见的汇编代码分为AT&T风格（目的操作数在右）和Intel风格（目的操作数在左）两种

+ 给定一个二进制文件，我们可以使用反编译工具得到他们的汇编代码，如`objdump`。 
    + 默认情况下`objdump -d myhelloworld`生成AT&T风格的汇编
    + `objdump`提供`--intel`选项，支持生成Intel风格的汇编

###### objdump的一般使用
1. `objdump -d <binary-file>` 
    + `-d`:表示`disassemble`反汇编
    + 直接使用`objdump`反汇编全部的二进制文件，结果可能比较大，不方便看。可以结合其他工具进一步分析。

> 图形化反编译工具有`IDA`和`Ghidra`，一键F5相当方便。

+ 如果要反编译某个函数，可以使用`gdb`的`disassemble`功能。当然，`gdb`的`disassemble`不仅仅用于反编译函数，还有其他使用技巧，如指定地址范围、反编译当前指令处的代码（`$pc`）。

```bash
# 使用objdump的-D --disassemble=sym
ouc@islouc-vm:~/attacklab$ objdump --disassemble=main ctarget

ctarget:     file format elf64-x86-64


Disassembly of section .init:

Disassembly of section .plt:

Disassembly of section .plt.sec:

Disassembly of section .text:

0000000000401779 <main>:
  401779:       f3 0f 1e fa             endbr64
  40177d:       41 56                   push   %r14
  40177f:       41 55                   push   %r13
  401781:       41 54                   push   %r12

# 使用gdb的disassemble
pwndbg> disassemble main
Dump of assembler code for function main:
   0x0000000000401779 <+0>:     endbr64
   0x000000000040177d <+4>:     push   r14
   0x000000000040177f <+6>:     push   r13
   0x0000000000401781 <+8>:     push   r12
   0x0000000000401783 <+10>:    push   rbp

```

2. `-t`:输出符号表(如：函数名)

```bash

ouc@islouc-vm:~/attacklab$ objdump --syms ctarget | grep main
0000000000000000 l    df *ABS*  0000000000000000              main.c
0000000000000000       F *UND*  0000000000000000              __libc_start_main@@GLIBC_2.2.5
0000000000401779 g     F .text  00000000000001f0              main
```

> but，使用`objdump`查看函数名这种方式不够简洁。更推荐使用`readelf`、`nm`、以及`gdb`里的`info functions`功能

```bash
# 使用readelf
ouc@islouc-vm:~/attacklab$ readelf -s ctarget | grep main
    14: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)
    42: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
   102: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
   141: 0000000000401779   496 FUNC    GLOBAL DEFAULT   15 main

# 使用 nm
ouc@islouc-vm:~/attacklab$ nm ctarget |grep main
                 U __libc_start_main@@GLIBC_2.2.5
0000000000401779 T main

# 使用gdb + info functions
pwndbg> info functions touch
All functions matching regular expression "touch":

File visible.c:
24:     void touch1();
39:     void touch2(unsigned int);
70:     void touch3(char *);

```

3. `-r`:输出重定位表内容

```bash
ouc@islouc-vm:~/attacklab$ objdump -r ctarget

ctarget:     file format elf64-x86-64
```


###### objdump与漏洞利用
> 在漏洞利用中，可以手动编写汇编指令片段（`myshellcode.asm`文件），使用汇编工具(`nasm`或`as`)生成对应的机器码(`myshellcode.o`文件)。我们可以使用`objdump -d myshellcode.o`提取这些机器码。

## GNU Debugger(GDB)

#### gdb
> gdb 远程调试怎么搞

- 支持多种编程语言
  - `C、C++、Fortran、Go、Rust`(部分)、`Pascal、Modula-2、Ada、D、Objective-C、Assembly`
  - GDB会自动检测并使用目标程序的语言（根据编译时的**调试信息**推断源代码的语言）
  - 当然，可使用`set lanuage`手动指定语言；
  - 使用`help set lanuage`查看GDB支持的语言列表
- `gcc -g` 和 `strip`命令
  - 使用`gcc -g`选项，让编译器在生成可执行文件时加入调试信息（存储在DWARF或STABS格式的调试符号中）
    - 调试信息包括：
      - 变量名称、类型、作用域
      - 函数名称、参数、返回类型
      - 源代码文件与行号的映射
      - 代码优化信息等
  - `strip`命令可用于从可执行文件中移除调试信息
    - 属于GNU binutils工具集
    - 用于删除ELF可执行文件（或共享库）的符号表、调试信息（包括变量名、函数名、源码行号）等，以减少文件体积并提高加载速度
    - 经过`strip`处理后的程序，使用GDB进行调试时，只能看到编译级信息

###### gdb常用命令
1. 设置参数
   + `(gdb) set args 参数1 参数2 ... //在启动gdb之后，运行程序之前`  
   + 查看设置的命令行参数`(gdb) show args`  

2. 运行、退出
   + `run`/`r`:运行当前程序。若设置了断点，则停在第一个断点的位置；否则程序正常执行
   + `start`:在main函数前设置断点，并运行当前程序
   + `attach pidxx`:使用gdb调试pidxx进程所运行的程序
   + `quit`: 退出

3. 查看源码
   + `list`/`l`
   + `list 行号`：行号对应的上下文内容，默认显示10行内容  
     + `set listsize 函数`设置显示行数
   + `list 函数名`函数名对应的上下文内容  
   + `list 文件名:行号`、`list 文件名:函数名`

4. 设置断点
+ 设置普通断点到当前文件

```bash
# break == b 
(gdb) b 行号
(gdb) b 函数名
```

+ 设置普通断点到某个非当前文件

```bash
# break == b 
(gdb) b 文件名:行号
(gdb) b 文件名:函数名
```

+ 设置条件断点
```bash
# 满足某个条件，程序才会停在这个断点位置
(gdb) b 行数 if 变量名==某个值
```

+ 删除断点
```bash
# delete == d 
(gdb) d 1 # 删除第一个断点
(gdb) d 1-5 # 删除第1到5个断点
```

+ 设置断点状态
  + `disable 断点编号`设置为不可用状态
  + `enable 断点编号`设置为可用状态
  
5. 调试命令
+ 继续运行 `continue`/`c`
+ 打印变量 `print`/`p`
  + 如果变量是整数，还可以指定输出格式
    + `/x`十六进制；`/d`有符号、十进制 ；`/u`无符号、十进制；`/o`八进制；`/t`二进制；`/f`浮点数；`/c`字符
  + 指定格式打印变量 `print/fmt 变量名`
  + 打印变量类型 `ptype 变量名`
+ 单步调试
  + `step`/`s`：单步调试，若有循环体会进入循环体内部
  + `next`/`n`：不进入循环体内部
  + `finish`：结束s单步调试，跳出循环体
  + `until`:直接跳出某个循环体
#### gdb插件 peda

#### gdb插件 pwndbg

