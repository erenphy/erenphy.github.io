---
layout:     post
title:      ROP
subtitle:   堆栈
date:       2023-12-14
author:     汤汤
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 堆
    - 栈
    - 内存
---
### 变量与常量
- 常量
  - 包括整型常量、实型常量、字符常量、字符串常量、符号常量[^100] 
  
  [^100]:**符号常量**，用DEFINE宏定义。 

  - 与常变量相比，常量是没有名字的不变量
+ 变量
  + 有名字的、具有特定属性的存储单元
  + 静态变量
    + 由static修饰
+ 常变量
  + 有名字的不变量，便于在程序中被引用
  + C99允许使用常变量（`const int a = 3`）
  + 常变量有变量的基本属性：有类型，占存储单元

###### define符号常量与const常变量有何区别
```cpp
// 符号常量
// define是预编译指令，在预编译时进行字符串替换
// 这意味着，预编译结束后，符号常量就不复存在了
// 即，不需要给符号常量的名字分配存储单元
#define PI 3.1415926 
// 常数变量
// 要占用存储单元
const float pi = 3.1415926 
```
###### const常变量与static静态变量有何区别
+ const 只读常变量，放在只读数据区，类似于一种保证`i promise that i will never try to change it`
+ static 静态变量，只能初始化一次






### 编译
> 编译过程
    > (从.c文件到可执行文件)
    >   $hello.c\Rightarrow$ 
    >   Preprocessing预处理$=hello.i \Rightarrow $ 
    >   compilation编译： $=hello.s\Rightarrow$ 
    >   assembly汇编 $=hello.o\Rightarrow$ 
    >   linking链接 $=\Rightarrow$
    >   $hello$

|序号|阶段|行为|备注|
|--|:--:|:--|:--|
|1|预处理Preprocessing|展开所有的`#define`宏定义；<br>处理`#if`、`#ifdef`、`#elif`、`#else`、`#endif`等；<br>处理`#inlcude`，将被包含的文件直接插入；<br>删除注释； <br>添加行号和文件标识；<br>保留`#program`编译器指令；<br> `gcc -E hello.c -o hello.i`进行预处理，输出文件.i|预处理器cpp|
|2|编译compilation||汇编器ccl|


###### 标识符
> 标识符：
> 对变量、符号常量名、函数、数组、类型等命名的有效字符序列
> 即，一个对象的名字
> C语言规定标识符只能由**字母下划线和数字**组成，且第一个字符必须为字母或下划线，且区分大小写


### 内存分类

###### CPP中的五分类
+ 栈：编译器自动分配和释放，一般存储 **局部变量**、**函数参数** 和 **函数返回地址** 
+ 堆：new分配；delete释放
+ 自由存储区：malloc分配；free回收
+ 全局、静态变量存储区
+ 常量存储区

###### 我自己的C++内存布局

| 高地址 |内核 | 存储内容 |备注 |  
| -- | :--:   | :--| :--: | 
| | 栈|返回地址；<br>函数参数;<br>局部变量||  
| |栈空间| |由高地址向低地址，<br>快速，连续，空间有限|   
|内存映射|高效的I/O映射| | |  
|  |堆空间| | |  
| | 堆   | |由低地址向高地址，<br>缓慢，不连续（链表），空间大|  
|    .bss    |                  | 未初始化数据     |运行前由内核初始化为0|  
|    .data   |读写数据段.WR data | 初始化的全局变量 |<br>编译并链接后得到|  
|    .data（只读）   |只读数据段.RO data | 初始化的静态变量 |由`const`修饰<br>编译并链接后得到|  
|    .text（只读）   | 代码段    | 可执行代码| 有效防止堆栈溢出；<br> 共享的；只读的；<br>编译并链接后得到|   

+ 栈$\Downarrow$：非静态局部变量、函数参数、返回值等
+ 内存映射段[^0]：文件映射、动态库、匿名映射

[^0]: 内存映射段是一种高效的I/O映射方式，用于加载一个共享的动态内存库。用户可使用系统interface创建共享内存，用作**进程通信**。

+ 堆[^1]$\Uparrow$：用于程序运行时的动态内存分配，**是由程序员自己分配的** 

[^1]: 堆区域从BSS段的末尾开始，向上增长。堆区域由所有共享库和进程中动态加载的模块共享。 

+ 全局数据段[^2]：全局数据，静态数据[^b]
[^2]:数据段分为初始化数据段$.data$和未初始化数据段$.bss$。$.data$包括程序员初始化的全局变量和静态变量，可进一步划分为**只读区域**和**读写区域**；$.bss$在程序开始之前由内核初始化为0，包括所有初始化为0的和没有显式初始化的全局变量和静态变量。
[^b]:静态数据包括用static修饰的静态变量和常量
+ 代码段[^3]：可执行代码，只读常数[^a]
[^3]:$.text$放在堆栈下面，可以防止堆栈溢出覆盖。通常代码段是**共享**的（对于经常执行的程序，只需要存储一个副本在内存中）代码段是**只读**的，以防止程序以外修改指令。 
[^a]:只读常数，readonly常数。不在编译时确定，而是在运行时确定
###### 四分类
- 栈区
- 堆区
- 全局数据区
- 代码区

### 栈
> 由高地址向低地址，快速，连续，空间有限
### 堆
> 由低地址向高地址，缓慢，不连续，空间大
