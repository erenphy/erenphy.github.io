---
layout:     post
title:      ELF标准格式
subtitle:   动态链接与静态链接
date:       2023-12-13
author:     汤汤
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 编译
    - cpp
---
> 来自《深入理解计算机系统》
## 静态链接
#### ELF-64可重定位目标文件

```markdown
-----------------------  
|     ELF header      |  
-----------------------  
|      .text          |  // 已编译的程序机器代码  
-----------------------  
|     .rodata         |  // 只读数据  
-----------------------  
|      .data          |  // 已初始化的全局和静态变量  
-----------------------  
|       .bss          |  // 未初始化的全局和静态变量  
-----------------------  
|      .symtab        |  // 程序定义引用的func和global信息  
-----------------------  
|                     |  // .text节中位置的列表?linking时需要修改  
|     .rel.text       |  // 调用外部func或引用global的指令需要修改  
|                     |  // 调用本地func不需要修改  
-----------------------    
|                     |  // 被引用或定义的global的重定位信息  
|     .rel.data       |  // 已初始化的全局变量若初始值是全局变量地址或外部定义函数的地址，则需要被修改  
|                     |   
-----------------------  
|                     |  // 调试符号表，条目包括：  
|      .debug         |  // 局部变量和类型定义、定义和引用的全局变量，以及原始的C源文件  
|                     |  // 以 - g 选项调用编译器驱动程序时，才 会得到这张表  
-----------------------  
|      .line          |  // 原始程序的行号与.text节中机器指令的映射  
|                     |  // 以 - g 选项调用编译器驱动程序时，才 会得到这张表  
-----------------------  
|      .strtab        |  // 包括.symtab和.debug节中的符号表，以及节头部中的节名字  
-----------------------  
|      节头部表        |  
-----------------------  

```

##### symtab节

```c
// code/link/elfstructs.c
typedef struct {
    int     name;      /* String table offset */
    char    type:4,    /* Function or data (4 bits) */
            binding:4; /* Local or global (4 bits) */
    char    reserved;  /* Unused */
    short   section;   /* Section header index */
    long    value;     /* Section offset or absolute address */
    long    size;      /* Object size in bytes */
} Elf64_Symbol;
```
#### 可执行目标文件
linker把多个目标文件合并成一个可执行目标文件

```markdown
-----------------------  
|     ELF header      |  
-----------------------  
|      段头部表        |  // 将连续的文件节映射到运行时内存段  
----------------------- 
|      .init          |  
-----------------------
|      .text          |  
-----------------------  
|     .rodata         |   
-----------------------   // 以上为代码段/只读内存段  
|      .data          |    
-----------------------  
|       .bss          |   
-----------------------   // 以上为数据段/读写内存段  
|      .symtab        |    
----------------------- 
|      .debug         |  
-----------------------  
|      .line          |  
-----------------------  
|      .strtab        |   
-----------------------  
|      节头部表        |  // 描述目标文件的节  
-----------------------  // 以上为不加载到内存的符号表和调试信息  

```

#### 加载目标文件
> 加载器loader将可执行目标文件中的代码和数据从磁盘复制到内存，然后通过跳转到程序的第一条指令或入口点来运行该程序。

## 动态链接共享库
#### 共享库 Shared Library
> 共享库的存在合理性：
>   静态库需要定期的维护和更新

> 动态链接的存在合理性:
>   静态链接中，假设两个程序共享一个模块，则静态链接后输出的两个可执行文件中各有一个共享模块的副本，若同时运行这两个可执行文件，则共享模块在磁盘和内存中都有两个副本，造成了磁盘和内存的极大浪费。

**共享库.so**是一个目标模块，在运行或加载时，可以加载到任意的内存位置，并和内存中的程序链接，整个过程称为 **动态链接**  

![dynamiclinker](https://raw.githubusercontent.com/erenphy/picIMG/main/dynamiclinker.png)

#### 动态链接器工作流程

| 步骤 | 描述 |  
|-----|------|    
| 1. 加载可执行文件 | 操作系统加载程序的可执行文件到内存中。 |  
| 2. 查找依赖的动态链接库 | 操作系统查找并加载程序所需的动态链接库，可以是系统默认路径下的库或自定义路径下的库。 |  
| 3. 符号解析 | 动态链接器遍历可执行文件和动态链接库，解析程序中对这些库的符号引用，例如函数名或变量名。 |  
| 4. 重定位 | 解析完成后，动态链接器将符号引用重定位到相应的库中的实际内存地址。 |  
| 5. 加载完成 | 当所有的符号解析和重定位工作完成后，动态链接器通知操作系统加载过程结束，程序准备就绪可以执行。 |  
| 6. 运行时操作 | 在程序执行过程中，动态链接器还可以进行一些额外的运行时操作，例如动态加载新的库、处理符号冲突等。 |  

huf

