---
layout:     post
title:      ELF标准格式
subtitle:   动态链接与静态链接
date:       2023-12-13
author:     汤汤
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 编译
    - cpp
    - 链接
---
> 来自《深入理解计算机系统》  

## 写在前面
#### ELF-64可重定位目标文件的格式
> ELF(executable and linkable format)  
>   常见的文件类型包括：可执行文件、共享库.so、目标文件.o和core文件  

##### ELF链接视图
> ELF Linking View  

##### ELF执行视图
> ELF Execution View  




```markdown
-----------------------  
|     ELF header      |  // 文件基本信息:文件类型(可执行文件、共享库、目标文件)、机器架构（arm、x86）、入口点地址  
-----------------------  
|      .text          |  // 已编译的程序机器代码  
-----------------------  
|     .rodata         |  // 只读数据  
-----------------------  
|      .data          |  // 已初始化的全局和静态变量  
-----------------------  
|       .bss          |  // 未初始化的全局和静态变量  
-----------------------  
|      .symtab        |  // 程序定义引用的func和global信息  
-----------------------  
|                     |  // .text节中位置的列表?linking时需要修改  
|     .rel.text       |  // 调用外部func或引用global的指令需要修改  
|                     |  // 调用本地func不需要修改  
-----------------------    
|                     |  // 被引用或定义的global的重定位信息  
|     .rel.data       |  // 已初始化的全局变量若初始值是全局变量地址或外部定义函数的地址，则需要被修改  
|                     |   
-----------------------  
|                     |  // 调试符号表，条目包括：  
|      .debug         |  // 局部变量和类型定义、定义和引用的全局变量，以及原始的C源文件  
|                     |  // 以 - g 选项调用编译器驱动程序时，才 会得到这张表  
-----------------------  
|      .line          |  // 原始程序的行号与.text节中机器指令的映射  
|                     |  // 以 - g 选项调用编译器驱动程序时，才 会得到这张表  
-----------------------  
|      .strtab        |  // 包括.symtab和.debug节中的符号表，以及节头部中的节名字  
-----------------------  
|      节头部表        |  
-----------------------  

```

##### symtab节

```c
// code/link/elfstructs.c
typedef struct {
    int     name;      /* String table offset */
    char    type:4,    /* Function or data (4 bits) */
            binding:4; /* Local or global (4 bits) */
    char    reserved;  /* Unused */
    short   section;   /* Section header index */
    long    value;     /* Section offset or absolute address */
    long    size;      /* Object size in bytes */
} Elf64_Symbol;
```

##### GOT节



#### 可执行目标文件的结构
linker把多个目标文件合并成一个可执行目标文件

```markdown
-----------------------  
|     ELF header      |  
-----------------------  
|      段头部表        |  // 将连续的文件节映射到运行时内存段  
----------------------- 
|      .init          |  
-----------------------
|      .text          |  
-----------------------  
|     .rodata         |   
-----------------------   // 以上为代码段/只读内存段  
|      .data          |    
-----------------------  
|       .bss          |   
-----------------------   // 以上为数据段/读写内存段  
|      .symtab        |    
----------------------- 
|      .debug         |  
-----------------------  
|      .line          |  
-----------------------  
|      .strtab        |   
-----------------------  
|      节头部表        |  // 描述目标文件的节  
-----------------------  // 以上为不加载到内存的符号表和调试信息  

```

#### 加载目标文件的过程
> 加载器loader将可执行目标文件中的代码和数据从磁盘复制到内存，然后通过跳转到程序的第一条指令或入口点来运行该程序。

#### E

## 动态链接共享库
#### 共享库 Shared Library
> 共享库的存在合理性：  
>   静态库需要定期的维护和更新

> 动态链接的存在合理性：
>   静态链接中，假设两个程序共享一个模块，则静态链接后输出的两个可执行文件中各有一个共享模块的副本，若同时运行这两个可执行文件，则共享模块在磁盘和内存中都有两个副本，造成了磁盘和内存的极大浪费。

**共享库.so**是一个目标模块，在运行或加载时，可以加载到任意的内存位置，并和内存中的程序链接，整个过程称为 **动态链接**  

<!-- ![dynamiclinker](https://raw.githubusercontent.com/erenphy/picIMG/main/dynamiclinker.png) -->

[//]: # (html语法实现控制图片大小和居中)  

<p align="center">
<img src="https://raw.githubusercontent.com/erenphy/picIMG/main/dynamiclinker.png" alt="dynamiclinker" width="400">
</p>

#### 动态链接与静态链接的区别
+ 静态链接  
  + 将头文件的库全部加载到链接后的可执行文件中  
+ 动态链接  
  + 将某些符号的重定位推迟到程序执行阶段  
  + 减少库中无用函数带来的可执行文件过大  
  
```
+---------------------+     +---------------------+
|       可执行文件     |     |       可执行文件     |
|  +---------------+  |     |  +---------------+  |
|  |   程序代码    |  |      |  |   程序代码    |   |
|  +---------------+  |     |  +---------------+  |
|  |   静态库函数  |  |      |  |   动态链接库  |  |
|  +---------------+  |     |  +---------------+  |
|  |   其他资源    |  |      |  |   其他资源    |  |
|  +---------------+  |     |  +---------------+  |
+---------------------+     +---------------------+
```

#### 动态链接器工作流程

| 步骤 | 描述 |  
|-----|------|    
| 1. 加载可执行文件 |加载可执行文件到内存中|  
| 2. 查找依赖的动态链接库 | 查找并加载程序所需的动态链接库，可以是系统默认路径下的库或自定义路径下的库|  
| 3. 符号解析 | 动态链接器遍历可执行文件和动态链接库，解析程序中对这些库的符号引用(函数名或变量名) |  
| 4. 重定位 | 动态链接器将符号引用重定位到相应的库中的实际内存地址 |  
| 5. 加载完成 | 当所有的符号解析和重定位工作完成后，动态链接器通知OS加载过程结束，程序准备就绪可以执行。 |  
| 6. 运行时操作 | 在程序执行过程中，动态链接器还可以进行一些额外的运行时操作，如动态加载新的库、处理符号冲突等。 |  

##### 延迟绑定
+ 

##### DDL和SO都是啥

> DLL: Dynamic link libraries 
> SO: Shared object  

+ dll和so是不同OS上的动态链接库  
  + dll是window使用的动态链接库格式，通常用于windows平台上的程序；Windows程序下hi用`LoadLibrary`和 `GetProAddress`等程序动态加载   
  + so是类unix系统使用的动态链接库格式，通常用于类unix系统上的程序；类Unix程序使用`dlopen`和`dlsym`等函数动态加载


