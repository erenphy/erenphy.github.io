---
layout: post
title: "CET与IBT"
date: 2025-01-06 
tags: [CET, IBT, 控制流劫持, ROP, DEP]
---

## 控制流劫持技术 (Control-Flow Hijacking)
> 篡改程序的正常执行流，来执行恶意代码（执行恶意的 shellcode 或代码复用攻击，如 ROP）

**常见的实现方式：**
- 栈溢出修改返回地址
- 修改函数指针，间接跳转劫持

#### 简单形式：代码注入攻击-执行shellcode
#### 进阶：代码重用攻击-ROP-返回式编程 
> 用处：绕过**DEP**（数据执行保护）
+ Gadget:以`ret`指令为结尾的代码片段（程序中合法的代码片段）
+ ROP链：精心设计的gadgets

#### 进阶：代码重用攻击-JOP-面向跳转的编程


## 控制流完整性（Control-Flow Integrity）
## 防御技术
### ASLR 地址空间布局随机化

### DEP 数据执行保护
+ 限定内存页不能同时具有执行权限和写权限  
+ 预防shellcode注入

### 基于硬件--控制流强制技术 CET
+ Control-flow Enforcement Technology
+ 基于硬件的
+ 预防控制流劫持攻击
    + 包括前向控制流劫持(JMP CALL)
    + 后向控制流劫持（RET）
> 目前，64位内核中，仅支持**用户空间**`影子栈`和**内核空间**`IBT`


#### Shadow Stack-影子栈
> 在内存中分配第二个栈。影子栈是不能被应用直接修改的。
> 在执行函数调用（`CALL`指令）时，处理器将`返回地址`同时`push`到`原栈`和`影子栈`上。等函数返回时，比较`影子栈`的`返回地址`与`原栈`是否一致。若不同，则触发`control protection fault`

+ `影子栈`的实质是映射一块私有、匿名、只读的内存
    + 私有。相对的是共享
    + 匿名页面。相对的是文件页面，即映射到文件的页面。
    + 只读：影子栈只读，只用来存储返回地址。

#### IBT(Indirect-branch-tracking)-间接分支追踪
0. 间接分支
    + 依赖动态计算目标地址
    + 包括函数调用`call`、跳转`jmp`、`RET`
    + 目标地址通常保存在指针里
    + 一旦攻击者恶意填充目标地址内容，即可劫持控制流。

1. 间接分支追踪
> 验证间接调用(`CALL`)或跳转（`JMP`）的目标是否使用`endbr`操作码标记。

+ `endbr64`用于64位；`endbr32`用于32位
+ 用于间接分支保护。编译器在每个可间接调用的函数入口插入`endbr64`指令。如果`jmp``call`跳转到非`endbr`开头的函数，则CPU触发异常。
